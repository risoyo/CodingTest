# -*- coding:utf-8 -*-
# 小易来到了一条石板路前，每块石板上从 1 挨着编号为：1、2、3.......
# 这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为 K 的 石板，小易单次只能往前跳 K 的一个约数 (不含 1 和 K) 步，
# 即跳到K+X(X 为 K 的一个非 1 和本身的约数) 的位置。
# 小易当前处在编号为 N 的石板，他想跳到编号恰好为 M 的石板去
# 小易想知道最少需要跳跃几次可以到达。
# 例如：
# N = 4，M = 24：
# 4->6->8->12->18->24
# 于是小易最少需要跳跃 5 次，就可以从 4 号石板跳到 24 号石板
# 输入描述:
# 输入为一行，有两个整数N，M，以空格隔开。
# (4 ≤ N ≤ 100000)
# (N ≤ M ≤ 100000)
# 输出描述:
# 输出小易最少需要跳跃的步数,如果不能到达输出-1
#
# 输入例子 1:
# 4 24
#
# 输出例子 1:
# 5
# 输入例子 2:
# 8 85678
#
# 输出例子 2:
# 31
# 输入例子 3:
# 9 85678
#
# 输出例子 3:
# 31
# 输入例子 4:
# 89989 89989
#
# 输出例子 4:
# 89989 89989


def divisor(num):
    divi_num = []
    for i in range(2, num):
        if num % i == 0:
            divi_num.append(i)
    divi_num.sort()
    return divi_num


if __name__ == "__main__":
    a = "8 85678"
    b = a.split(" ")
    b = map(int, b)
    count = 0
    while b[0] < b[1]:
        divi_num = divisor(b[0])
        i = len(divi_num) - 1
        while i >= 0:
            if b[0] + divi_num[i] <= b[1]:
                b[0] = b[0] + divi_num[i]
                count += 1
                break
            else:
                i = i-1
    print count
